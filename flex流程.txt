 查看录像：  
    (1) MetaClass.mxml
		1.（初始化方法）
		onCreateComplete(event){
			metaManager = new MetaManager(this);
		}

    (2) MetaClass com.doer.manager.MetaManager.as	
		2.初始化分析	
		analysis = new VideoAnalysis(this,metaEdu.videoMask);
	
   （3）VideoAnalysis
		onLoginConversationReplay

   （4）loginController进行执行登录完全的监听事件
		执行：sendCommand(new LocalCommand(LocalCommandType.CMD_LOGIN_COMPLETE,response));
		LocalCommandType.CMD_LOGIN_COMPLETE所对应的方法：

   （5） MetaClass view LiveView.mxml	
    		onCreateComplete() 初始化
			video1.addEventListener(LiveVideo.LIVE_AUDIO_CHECK,onAudioCheck);进行监听

   （6） com.doer.modes.live.LiveController
		invalidateCommands() 监听登录事件(监听登录完成事件)
		onCommand()初始化录制
		onLoginInfo方法：this.process.invalidate();
		
   （7） com.doer.modes.live.process.LiveVideoProcess
		invalidate()方法中执行：
			recorderProcess.openRecorder();			

    (8)  LiveRecorderProcess		
		openRecorder()方法中执行：onAlertYes（）
		onAlertYes（）方法中执行：openVieoRecorder（）
		openAudioRecorder（）方法中执行：video.openAudio(audioKey,0);
		
    (9) liveVideoInfo
		 openAudio()方法中执行：openAudio（）这个方法是ILiveVideo接口中的方法，在VideoRecord.as中实现；
     
   （10）com.doer.modes.live.video.VideoRecord.as
		 openAudio()方法中：
			invalidate();这个方法是初始化RtmpSeparateRecorder对象
			recorder.openAudio(info.address, info.audioKey, toolsManager.micphoneIndex, toolsManager.micphoneVolume);
		
   （11）strongLiberary/src/com/strong/rtmp/RtmpSeparateRecorder  
		 openAudio() 打开音频发放中执行：connectAudio（）		 
		 connectAudio（）方法中：checkAudioStatus（）
		 checkAudioStatus（）方法中执行：
			 this.dispatchEvent(new RtmpRecorderEvent(RtmpRecorderEvent.AUDIO_RECORD_CHECK,curInfo));
			
		 
   （12）VideoRecord.as
		invalidate()这个方法中进行了监听RtmpRecorderEvent.AUDIO_RECORD_CHECK的事件方法onAudioCheckHandler（）；
		onAudioCheckHandler()这个方法中执行了LiveVideo.LIVE_AUDIO_CHECK的事件；
		

   （13）MetaCLass view.modes.live.LiveView.mxml
		onCreateComplete()方法中进行了音频监听;
		onAudioCheck方法中执行了：sendOpenAudio方法放送到mixio服务器；
   	


  	

  
  	strongLiberary/src/com/strong/rtmp/RtmpSeparateRecorder  
		openVideo() 打开视频
		openAudio() 打开音频
	
		connectionStatusHandler（）查看链接状态(附加音视频)
	




第三：登录检测
      1.MetaClass.as 
	注册socket监听：regist(new SocketController(this,ModeTypes.MODE_SOCKET_ID))
      
      2.SocketController.as
	构造方法中：
		this.initConn();初始化链接
	
       private function initConn() : void
       { 
         this.socketContainer = new NebulaSocketContainer(this);
         this.socketContainer.start();
       }

       3.NebulaSocketContainer.as
		public function NebulaSocketContainer(param1:INebulaSocketHandler)
      		{
        		 super();
        		 NebulaSocketContainer._instance = this;
         		this._handler = param1;
         		this._socket = new NebulaSocket();
         		this._socket.addEventListener(NebulaSocketEvent.CLOSE,this.close);
         		this.configParams();
     		 }
	4.NebulaSocket.as
	   public function NebulaSocket()
      		{
         	super();
         	this.container = NebulaSocketContainer.instance;
         	this.handler = this.container.handler;
         	this.decoder = NebulaExternalDecoder.instance;
         	this.encoder = NebulaExternalEncoder.instance;
         	this.addEventListener(ProgressEvent.SOCKET_DATA,this.doDecode);
         	this.addEventListener(Event.CONNECT,this.doVerify);
         	this.addEventListener(IOErrorEvent.IO_ERROR,this.nError);
         	this.addEventListener(SecurityErrorEvent.SECURITY_ERROR,this.nError);
         	this.addEventListener(Event.CLOSE,this.nClose);
      		}
	5.NebulaSocketContainer.as(进行了第一次握手)
	  public function start(param1:Boolean = true) : void
      	{
         	if(!param1)
         	{
            		if(this._socket.interruptType != NebulaSocketInterruptType.UNNECESSARY)
           	 {
               		log.debug("start","异常状态，无法启动连接");
              		 return;
            	}
         	}
         	else
         	{
            	this._socket.interruptType = NebulaSocketInterruptType.UNNECESSARY;
         	}
         	clearTimeout(this._reStartTimeout);
         	this._socket.nConnect(this._isKeepAlive,this._params.servAddress[0],80);
      	 }

	 6.mixio中（ExternalDecoder类）
		if (!connection.containsAttribute("isInited")) {
      			return initSession(connection, in, out);
    		}
		服务器接受，返回；（第二次握手）

	 7.之前第4步中配置了返回后执行的方法（this.addEventListener(Event.CONNECT,this.doVerify)）
	   	doVerify()
		 private function doVerify(param1:Event) : void
      		{
         		this.isHandshaked = true;
         		this.encoder.verify(this);
      		 }
	   this.encoder是：NebulaExternalEncoder
	   verify()方法：
		public function verify(param1:NebulaSocket) : void
      		{
         		var _loc2_:String = null;
         		var _loc3_:String = null;
         	  if(param1.connected && !param1.isVerified)
         		{
            			_loc2_ = param1.isKeepAlive?"Keep-Alive":"Close";
           			 _loc3_ = "GET " + param1.application + " HTTP/1.1\r\n" + "Connection: " + _loc2_ + "\r\n" + "Host: " + param1.servAddr + ":" + param1.servPort + "\r\n" + "User-Agent: Mozilla/5.0 Chrome/27 Safari/537.36\r\n\r\n";
            			param1.writeMultiByte(_loc3_,"utf-8");
         	  }
      		 }
	
	 	

	8.mixio接受（ExternalDecoder类）
	   方法：doDecode（）
	   返回信令：MixioToClientMessage（） businessType:200000 result:201
	 
	9.之前第4步中配置了链接成功后放回的执行方法(this.addEventListener(ProgressEvent.SOCKET_DATA,this.doDecode);)	   
      
           private function doDecode(param1:ProgressEvent) : void
          {
            	var _loc2_:ClientConn = null;
         	if(!this.isVerified)
         	{
            		if(this.decoder.verify(this))
            		{
              		 this.isVerified = true;
               		_loc2_ = new ClientConn();
               		_loc2_.session = NebulaSocketContainer.instance.handler.session;
               		_loc2_.lastStamp = "";
               		this.encoder.encodeMessage(this,_loc2_,"");
            		}else{
               		log.log(LogType.CONNECT_VERIFY_FAIL,"doDecode","安全验证失败",this.servAddr + ":" + this.servPort);
               		this.interruptType = NebulaSocketInterruptType.SERVER_INVALID;
            		}
         	}else{
            		this.decoder.decode(this);
         	}
      	   }

	10.NebulaExternalDecoder.as(这是decode具体方法)
	   public function decode(param1:NebulaSocket) : void
      	{
         var _loc2_:* = false;
         var _loc3_:* = 0;
         var _loc4_:* = 0;
         var _loc5_:ByteArray = null;
         var _loc6_:Object = null;
         var _loc7_:* = 0;
         var _loc8_:String = null;
         var _loc9_:* = 0;
         var _loc10_:* = 0;
         var _loc11_:String = null;
         if(!this.isDecoding)
         {
            this.isDecoding = true;
            _loc2_ = true;
            _loc3_ = 0;
            _loc4_ = 0;
            while(_loc2_)
            {
               _loc3_ = param1.bytesAvailable;
               if(!this.isReadHead && _loc3_ > 4)
               {
                  this.readedLength = param1.readInt();
                  _loc3_ = _loc3_ - 4;
                  this.isReadHead = true;
               }
               if(this.isReadHead && this.readedLength != 0 && _loc3_ >= this.readedLength)
               {
                  _loc5_ = new ByteArray();
                  param1.readBytes(_loc5_,0,this.readedLength);
                  if(_loc5_[0] == 113)
                  {
                     _loc6_ = _loc5_.readMultiByte(_loc5_.length,"utf-8");
                     param1.nResponse();
                  }
                  else
                  {
                     _loc7_ = _loc5_.readByte();
                     _loc8_ = "";
                     _loc9_ = 0;
                     if(_loc7_ != NebulaMessageTransmitType.CONN)
                     {
                        _loc8_ = _loc5_.readMultiByte(16,"utf-8");
                        _loc9_ = 16;
                     }
                     _loc10_ = _loc5_.readInt();
                     _loc11_ = _loc5_.readUTFBytes(this.readedLength - 1 - _loc9_ - 4);
                     switch(_loc10_)
                     {
                        case NebulaMessageBusinessType.SERVER_CONN_RESP:
                           param1.nConnectedHandler(_loc11_);
                           break;
                        case NebulaMessageBusinessType.SERVER_SEND_FIN:
                           param1.nServerSendFin();
                           break;
                        case NebulaMessageBusinessType.SERVER_RECV_FIN:
                           param1.nServerReciveFin(_loc11_);
                           break;
                        case NebulaMessageBusinessType.SERVER_SIGN_IN_RESP:
                           param1.nSignInRespHandler(_loc11_);
                           break;
                        case NebulaMessageBusinessType.SERVER_SIGN_OUT_RESP:
                           param1.nSignOutRespHandler(_loc11_,false);
                           break;
                        case NebulaMessageBusinessType.SERVER_PASSIVE_OUT_INFORM:
                           param1.nSignOutRespHandler(_loc11_,true);
                           break;
                        default:
                           param1.nMessageHandler(_loc10_,_loc11_,_loc8_);
                     }
                  }
                  this.isReadHead = false;
                  this.readedLength = 0;
               }
               else
               {
                  _loc2_ = false;
               }
            }
            this.isDecoding = false;
           }
      	  }
	 
         11.上面的这个方法param1.nConnectedHandler(_loc11_);在NebulaSocket中实现
	    nConnectedHandler方法：
		public function nConnectedHandler(param1:String) : void
      		{
         		var _loc4_:ClientSignIn = null;
         		var _loc2_:ServerConnResp = JsonUtils.convertJsonToClass(param1,ServerConnResp);
         		var _loc3_:int = _loc2_.result;
         		if(_loc3_ == NebulaMessageResult.OK)
         	{
            		this.handler.clientLastStamp = _loc2_.lastStamp;
            		this.doSendMessage();
            		log.debug("nConnectedHandler","正常连接");
         	}
         		else if(_loc3_ == NebulaMessageResult.OFFLINED)
         	{
            		this.handler.offlineClear();
            		this.handler.clientLastStamp = _loc2_.lastStamp;
            		this.doSendMessage();
            		log.debug("nConnectedHandler","从离线状态恢复");
         	}
         		else if(_loc3_ == NebulaMessageResult.CREATED)
         	{
            		_loc4_ = new ClientSignIn();
            		_loc4_.isGeneral = this.handler.isGeneralLogin?1:0;
            		_loc4_.institutionId = this.handler.institutionId;
            		_loc4_.account = this.handler.account;
            		_loc4_.password = this.handler.password;
            		_loc4_.deviceMark = this.handler.deviceMark;
            		_loc4_.platform = this.handler.platform;

            		this.encoder.encodeMessage(this,_loc4_,TimeUtils.getNebulaStamp(new Date()));
            		this.isUpdated = true;
            		log.debug("nConnectedHandler","发送登录数据");
         	}
         		else if(_loc3_ == NebulaMessageResult.SIGNOUTED)
         	{
            		log.log(LogType.CONNECT_SINGOUTED,"nConnectedHandler","已经注销退出 ",this.remoteAddress + ":" + this.remotePort);
            		this.interruptType = NebulaSocketInterruptType.SIGN_OUT;
         	}
         		else if(_loc3_ == NebulaMessageResult.REFUSED)
         	{
            		log.log(LogType.CONNECT_REFUSED,"nConnectedHandler","服务器拒绝连接",this.remoteAddress + ":" + this.remotePort);
            		this.interruptType = NebulaSocketInterruptType.SERVER_REFUSED;
         	}
         		else if(_loc3_ == NebulaMessageResult.UNSUPPORTED)
         	{	
            		log.log(LogType.CONNECT_PROTOCAL_ERROR,"nConnectedHandler","连接协议版本不符合要求",this.remoteAddress + ":" + 				this.remotePort);
            		this.interruptType = NebulaSocketInterruptType.PROTOCOL_ERROR;
            		this.handler.protocolError();
         	}
     	 	}
	  12. NebulaMessageResult.CREATED创建（ 状态码：201）:
		执行这个方法：this.encoder.encodeMessage(this,_loc4_,TimeUtils.getNebulaStamp(new Date()));
		
	        this.encoder:NebulaExternalEncoder.as(encodeMessage()的具体实现)；
          
	  13.mixio服务:ClientSignIn
		具体类： com.metaedu.server.mixio.external.ExternalAcceptorHandler
		处理方法：messageReceived（）；
	
	  14.NebulaExternalDecoder.as接收
		状态：NebulaMessageBusinessType.SERVER_SIGN_IN_RESP=200004
		对应的执行方法： param1.nSignInRespHandler(_loc11_);
		
		
	  15.NebulaSocket.as
		public function nSignInRespHandler(param1:String) : void
      		{
         		var _loc2_:ServerSignInResp = JsonUtils.convertJsonToClass(param1,ServerSignInResp);
         		if(_loc2_.result == NebulaMessageResult.OK)
         		{
            			this.handler.signInOK(_loc2_);
         		}else{
            			this.interruptType = NebulaSocketInterruptType.SIGN_OUT;
            			this.handler.signInFail();
         		}
      		}
		
	  16.SocketController.as(signInOK方法的具体实现)
		 public function signInOK(param1:ServerSignInResp) : void
      		{
         		(metaManager.getControllerById(ModeTypes.MODE_LOGIN_ID) as LoginController).invalidateLogin(param1);
      		}
	 
	  17.MetaClass中进行对SocketController进行监听（new SocketController（））
		public function SocketController(param1:MetaManager, param2:int, param3:Group = null)
      		{
         		this.localQueue = new Vector.<NebulaMessagePackage>();
         		this.socketSession = new SocketSession();
         		super(param1,param2,param3);
         		this.invalidateCommands();
         		if(!Global.isRecord)
         		{
            			this.initConn();
         		}
      		 }
		initConn的具体实现：
			private function initConn() : void
      			{
         			this.socketContainer = new NebulaSocketContainer(this);
         			this.socketContainer.start();
      			}
	   
	   	

	18.NebulaSocketContainer的构造函数：
	      public function NebulaSocketContainer(param1:INebulaSocketHandler)
      		{
         		super();
         		NebulaSocketContainer._instance = this;
         		this._handler = param1;//这个就是socketController
         		this._socket = new NebulaSocket();
         		this._socket.addEventListener(NebulaSocketEvent.CLOSE,this.close);
         		this.configParams();
      		}
	
	19.NebulaSocket.as中构造函数：
		public function NebulaSocket()
      		{
        	 super();
         	 this.container = NebulaSocketContainer.instance;
         	 this.handler = this.container.handler;//这个就是socketController
         	 this.decoder = NebulaExternalDecoder.instance;
         	 this.encoder = NebulaExternalEncoder.instance;
          	 this.addEventListener(ProgressEvent.SOCKET_DATA,this.doDecode);
         	 this.addEventListener(Event.CONNECT,this.doVerify);
         	 this.addEventListener(IOErrorEvent.IO_ERROR,this.nError);
         	 this.addEventListener(SecurityErrorEvent.SECURITY_ERROR,this.nError);
         	 this.addEventListener(Event.CLOSE,this.nClose);
      		}
		
	20.（16-19这几步是对15的的事件进行绑定的一个过程）；

	21.第16步执行的：(metaManager.getControllerById(ModeTypes.MODE_LOGIN_ID) as LoginController).invalidateLogin(param1);
	   方法具体实现是：LoginController中
		/**
		 * 初始化登录
		 * **/
		public function invalidateLogin(refMsg:ServerSignInResp):void
		{
			global.userId = refMsg.userId;
			global.account = refMsg.account;
			global.avatar = refMsg.avatar;
			global.name = refMsg.name;
			global.surname = refMsg.surname;
			global.sex = refMsg.sex;
			
			requestSocialInfo();
		}
		
		/**
		 * 请求社会关系
		 * **/
		private function requestSocialInfo():void
		{
			var groupTotal:ClientGroupsTotal = new ClientGroupsTotal(); //登录完成之后加载客户社交信息
			groupTotal.userId = global.userId;
			groupTotal.version = null;
			
			sendCommand(new LocalCommand(LocalCommandType.CMD_SEND_TO_SERVER,groupTotal));
			
		}
	22.之后要跟数据库同样的交互三次：
		override public function onRcv(param1:String, param2:int, param3:String = "") : void
      {
         var refContent:String = param1;
         var refBusinessType:int = param2;
         var refTimeStamp:String = param3;
         try
         {
            if(refBusinessType == NebulaMessageBusinessType.SERVER_GROUPS_TOTAL_RESP)
            {
               this.onSocialResponse(JsonUtils.convertJsonToClass(refContent,ServerGroupsTotalResp) as ServerGroupsTotalResp);
            }
            else if(refBusinessType == NebulaMessageBusinessType.SERVER_MEMBERS_TOTAL_RESP)
            {
               this.onMembersResponse(JsonUtils.convertJsonToClass(refContent,ServerMembersTotalResp));
            }
            else if(refBusinessType == NebulaMessageBusinessType.SERVER_COMPLEX_ENTER_RESP)
            {
               this.onLoginConversationReplay(JsonUtils.convertJsonToClass(refContent,ServerComplexEnterResp));
            }
            return;
         }
         catch(error:Error)
         {
            Tools.alert("登录到课堂会话失败！");
            return;
         }
      }
		
	
	 
	

